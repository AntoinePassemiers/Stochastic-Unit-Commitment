\chapter{Considérations générales sur l'implémentation}
\vspace*{1.2cm}

Dans le cadre de ce projet, nous avons fait le choix d'utiliser PuLP en tant qu'interface entre
\solver et Python. PuLP est une bibliothèque de modélisation de programmes linéaires et permet
la résolution de ces derniers au moyen de solveurs tels que GLPK, CBC, CLP ou autre.
L'API est stable et largement utilisée, mais contrairement à celle de la bibliothèque CVXPY,
elle ne permet pas de manipuler des variables ou des contraintes de manière vectorisée à l'aide
de matrices ou d'autres structures de données dédiées.

L'implémentation d'une formulation peut de fait devenir fastidieuse et les erreurs difficiles à
retracer lorsque l'on vient à définir des variables multi-indices (implémentables sous forme
de matrices de variables) et indicer ces dernières au sein de boucles. En effet l'absence d'erreur du programme
n'implique pas que les contraintes ont été correctement implémentées et toutes ajoutées au modèle.
Numpy apporte une sécurité supplémentaire relative à la dimensionalité: si par exemple un produit matriciel est effectué
entre une matrice de constantes et un vecteur de variables PuLP et que les dimensions sont incompatibles,
une exception est automatiquement levée. Ceci tient également pour la construction de contraintes où le membre de gauche ne possède pas
la même dimensionalité que le membre de droite, pour la somme de variables, etc.

\section{Extension de PuLP}

Pour les raisons que nous venons de donner, nous avons étendu Numpy afin de rendre l'indiçage 
fantaisiste ("fancy indexing") comptatible avec les variables PuLP. Pour ce faire, nous avons
simplement sous-classé les tableaux \textit{numpy.ndarray} et notamment réécrit les méthodes de comparaison.
La classe fille s'appelle \textit{LpVarArray}. Nous avons entre autres veillé à ce que:
\begin{itemize}
  \item Une combinaison linéaire d'objets \textit{LpVarArray} de dimensions compatibles résultent en un
  un nouvel objet \textit{LpVarArray}.
  \item Une comparaison entre deux \textit{LpVarArray} donne un tableau de contraintes PuLP.
  \item Les tableaux de contraintes PuLP puissent être ajoutés à une instance de problème.
  Pour ce faire, nous avons sous-classé \textit{pulp.LpProblem} en \textit{ArrayCompatibleLpProblem}
  et ajouté les méthodes requises.
\end{itemize}

Motivons nos choix d'implémentation par un exemple concret d'utilisation de ces nouvelles classes.
Supposons que $p$ soit un \textit{LpVarArray} tridimensionnel et $R_plus$ un \textit{numpy.ndarray} contenant 
des constantes. La modélisation peut donc se faire selon deux styles, et nous avons opté pour la seconde
version:
\begin{lstlisting}[language=Python]
    # Ajout séquentiel des contraintes
    for g in range(G):
        for s in range(S):
            for t in range(1, T):
                problem += (p[g, s, t] - p[g, s, t-1] <= R_plus[g])

    # Ajout des contraintes par fancy indexing
    problem += (np.swapaxes(p[:, :, 1:] - p[:, :, :-1], 0, 2) <= R_plus)
\end{lstlisting}

\section{Contenu du dossier source}

Voici comment l'implémentation du projet a été répartie:

\begin{itemize}
  \item \textit{decomposition.py}: Contient l'implémentation de l'unique fonction \textit{decompose\_problem}, permettant
  sur base d'une instance de type \textit{SUPInstance} de générer les instances des problèmes PuLP
  nécessaires, dont le problème original (PP), les sous problèmes issus de la décomposition lagrangienne ($P1_s$ et $P2$),
  ainsi que les problèmes de répartition économique pour chaque scénario ($ED_s$). Tous les problèmes/sous-problèmes
  partagent les variables PuLP, ce qui permet à la résolution d'un problème de \textbf{directement mettre à jour les valeurs
  des variables} dans les problèmes partageant ces mêmes variables, sans que nous ayons explicitement à le faire.
  \item \textit{dive\_and\_fix.py}: Implémentation de l'heuristique dive-and-fix, que nous avons gardé malgré les mauvaises
  performances de celle-ci.
  \item \textit{experimental.py}: Fichier bac à sable
  \item \textit{genetic.pyx}: Implémentation en "pur C" et parallèle d'un algorithme génétique permettant de minimiser
  le nombre de contraintes non satisfaites pour une instance du problème.
  \item \textit{heuristics.py}: Implémentation de \textit{evolve-and-fix} (voir tâche 2).
  \item \textit{instance.py}: Structure de données pour les constantes et indices du problème, accompagnée de fonctions
  utilitaires pour parser les différents fichiers d'instance. Notez la différence entre une instance \textit{SUPInstance}
  telle que définie dans ce fichier, et les instances des problèmes PuLP tels que définis à l'aide de la classe
  \textit{SUCLpProblem} dans le fichier \textit{utils.py}.
  \item \textit{lp\_relaxation.py}: Formulations du problème d'origine ainsi que de sa relaxation linéaire. Selon
  la formulation désirée, le problème est renvoyé sous forme d'une instance de la classe \textit{SUCLpProblem}.
  \item \textit{main.py}: Point d'entrée du programme et parseur de commandes
  \item \textit{subgradient.py}: Algorithme du sous-gradient permettant de trouver une solution duale sur base
  des sous-problèmes $P1_s$ et $P2$.
  \item \textit{utils.py}: Problèmes PuLP et intégration de NumPy dans PuLP telle que décrite dans la section précédente.
  \item \textit{variables.py}: Initialisation des variables nécessaires à la formulation du SUC. Les contraintes spéciales
  (bornes sur les variables) sont implictement ajoutées au problème. Par exemple, les variables $u_{gst}$ sont supposées
  entre comprises entre 0 et 1, et ce peu importe si la formulation choisie est le problème d'origine, la relaxation
  linéaire ou même la décomposition lagrangienne.
\end{itemize}