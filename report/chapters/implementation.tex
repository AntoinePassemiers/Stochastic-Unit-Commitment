\chapter{Considérations générales sur l'implémentation}
\vspace*{1.2cm}

Dans le cadre de ce projet, nous avons fait le choix d'utiliser PuLP en tant qu'interface entre
\solver et Python. PuLP est une bibliothèque de modélisation de programmes linéaires et permet
la résolution de ces derniers au moyen de solveurs tels que GLPK, CBC, CLP ou autre.
L'API est stable et largement utilisée, mais contrairement à celle de la bibliothèque CVXPY,
elle ne permet pas de manipuler des variables ou des contraintes de manière vectorisée à l'aide
de matrices ou d'autres structures de données dédiées.

L'implémentation d'une formulation peut de fait devenir fastidieuse et les erreurs difficiles à
retracer lorsque l'on vient à définir des variables multi-indices (implémentables sous forme
de matrices de variables) et indicer ces dernières au sein de boucles. En effet l'absence d'erreur du programme
n'implique pas que les contraintes ont été correctement implémentées et toutes ajoutées au modèle.
Numpy apporte une sécurité supplémentaire relative à la dimensionalité: si par exemple un produit matriciel est effectué
entre une matrice de constantes et un vecteur de variables PuLP et que les dimensions sont incompatibles,
une exception est automatiquement levée. Ceci tient également pour la construction de contraintes où le membre de gauche ne possède pas
la même dimensionalité que le membre de droite, pour la somme de variables, etc.

\section{Extension de PuLP}

Pour les raisons que nous venons de donner, nous avons étendu Numpy afin de rendre l'indiçage 
fantaisiste ("fancy indexing") comptatible avec les variables PuLP. Pour ce faire, nous avons
simplement sous-classé les tableaux \textit{numpy.ndarray} et notamment réécrit les méthodes de comparaison.
La classe fille s'appelle \textit{LpVarArray}. Nous avons entre autres veillé à ce que:
\begin{itemize}
  \item Une combinaison linéaire d'objets \textit{LpVarArray} de dimensions compatibles résultent en un
  un nouvel objet \textit{LpVarArray}.
  \item Une comparaison entre deux \textit{LpVarArray} donne un tableau de contraintes PuLP.
  \item Les tableaux de contraintes PuLP puissent être ajoutés à une instance de problème.
  Pour ce faire, nous avons sous-classé \textit{pulp.LpProblem} en \textit{ArrayCompatibleLpProblem}
  et ajouté les méthodes requises.
\end{itemize}

Motivons nos choix d'implémentation par un exemple concret d'utilisation de ces nouvelles classes.
Supposons que $p$ soit un \textit{LpVarArray} tridimensionnel et $R_plus$ un \textit{numpy.ndarray} contenant 
des constantes. La modélisation peut donc se faire selon deux styles, et nous avons opté pour la seconde
version:
\begin{lstlisting}[language=Python]
    # Ajout séquentiel des contraintes
    for g in range(G):
        for s in range(S):
            for t in range(1, T):
                problem += (p[g, s, t] - p[g, s, t-1] <= R_plus[g])

    # Ajout des contraintes par fancy indexing
    problem += (np.swapaxes(p[:, :, 1:] - p[:, :, :-1], 0, 2) <= R_plus)
\end{lstlisting}

\section{Contenu du projet}

\begin{itemize}
  \item \textit{decomposition.py}: 
  \item \textit{dive\_and\_fix.py}:
  \item \textit{experimental.py}:
  \item \textit{genetic.pyx}:
  \item \textit{instance.py}:
  \item \textit{lp\_relaxation.py}:
  \item \textit{main.py}:
  \item \textit{subgradient.py}:
  \item \textit{utils.py}:
  \item \textit{variables.py}:
\end{itemize}